1、面向对象语言中类成员在编译时的特征：
    无继承关系的类可以被分成两部分：变量和方法。静态变量存储在静态数据区，非静态变量如同普通的变量一样被编译，存储在该对象的数据结构中。若类的构造函数对这些变量赋值，则它们的值按序存储在对象所属的内存区域中。而方法如同普通的函数一样被编译，存放在代码段，以同样的指令被调用。调用某个对象的方法时的传参方式类似于调用一个接收该对象作为第一个参数的函数时的传参方式。
    当类涉及到继承或多态时，一个对象将不仅包含变量，还包含指向它所继承的方法的指针。每个派生类的对象将在自己的数据结构中拷贝一份从基类继承而来的变量，同时对每个虚方法，按照c++的虚方法继承规则，存储一个指向该对象所能调用的虚方法的地址。

2、源代码中类成员名在反汇编代码中的名字：
    类中的变量在反汇编代码中已经没有名字了，它们是通过地址被访问的。
    类中的成员函数名的转换方式为：_ZN/_ZZ + (namespacelength + namespace)* + methodnamelength + methodname + (C/D + number)? + E + v/i/c...
    _ZN是前缀，'N'用于成员函数，'_ZZ'用于声明为const的函数
    namespacelength是函数所在命名空间的名字长度
    namespace是函数所在命名空间的名字
    namespacelength和namespace可以有多层
    methodnamelength是方法名长度
    methodname是方法名
    C/D + number C表示构造函数，D表示析构函数，number表示不同类型的构造或析构函数，如C1表示complete object constructor，C2表示base object constructor等。
    E后面的符号表示函数的参数类型，如v表示void，ic表示第一个参数为int、第二个参数为char，等等。
    

3、
    动态链接时，可执行文件中只加入了指向库的指针（如文件名），在运行时库中的目标文件被加载。printf函数在反汇编代码中的名字变成了<printf@plt>，只对应了一条jmp指令，一条push指令和一条jmp指令。
    静态链接时printf函数所在库的目标文件代码被加入到可执行文件中，printf会调用_IO_printf函数，并进而调用_IO_vfprintf函数，相应的代码都包含在可执行文件中。
