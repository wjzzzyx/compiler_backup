分以下几部分阐述本实验的实现
一、基础部分    
    这部分的要求是：
    1、完成关键词的分析.
    2、完成行号的记录, 变量 curr_lineno 用来记录源码的行号(已经定义).
    3、程序中一个词法单位(lexeme) 往往出现多次, 比如一个变量名. 为了节省时间和空间, 编译器会把这些词法单元用一个 string table 保存. 在 cool-support 里面提供了一个 string table 的实现. 有三种 String Table： 字符串的、整型常量的、标识符的. 请填好这三个 String Table.
    4、此外，不用检查整型常量是否合适. 特殊的 Identifier (如 Object, Int, self 等)暂时不用特殊处理, 以后再说.
    由于除了true和false以外的关键词是大小写不敏感的，因此用flex中的（？：）正则表达式来定义关键字，例如if定义为（？:if）。而true和false可分别定义为(?i:(?-i:t)rue)和(?i:(?-i:f)alse)。当匹配到关键字或运算符等token时，只需返回该token类型的标号（已在cool-support/include/cool-parse.h中定义）。当匹配到true或false时，还需对yylval赋值以告诉语法分析器该布尔量的真假。
    Typeid是以大写字母开始并由字母、数字、下划线组成的串，Objectid是以小写字母开始并由字母、数字、下划线组成的串，因此匹配两者的正则表达式分别是[A-Z]({letter}|{digit}|_)*， [a-z]({letter}|{digit}|_)*。
    一个需注意的地方是匹配关键字的模式应放在匹配标识符的模式之前，这与flex消除二义的方式相一致。这样，这些关键字将成为保留字。
    无论是在普通状态下，还是在后叙的COMMENT或STRING状态下，每次匹配到非转义的换行符时，就将curr_lineno加1,以此实现行号的记录。
    当匹配到整数或标识符时，调用相应的符号表的add_string()函数向符号表中增加条目，并向语法分析器返回相应的类型标号。
    最后，用模式.来匹配所有的无效字符。
二、注释的处理
    对注释的要求是：
    1、注释有两种类型，形如(*...*)的注释可以嵌套。
    2、如果在注释中遇到了 EOF，则报错 "EOF in string comment"。不要为这个注释生成 token.
    3、在注释外遇到”*)“时报错，而不是返回两个符号*和）。
    对形如"--..."的注释的处理较简单，只需以--.*模式匹配它即可。因为.匹配除换行符外的所有字符，所以这一模式可以匹配整行注释直到遇到行末的换行符或EOF。
    对形如"(*...*)"的注释的处理需要用到flex的起始状态。起始状态被用来限定特定规则的作用范围，或者根据文件的特定内容来改变词法分析器的工作方式。起始状态有两种，分别是用%s声明的共享模式和用%x声明的独占模式，两者的差异在于在独占的起始状态下，没有任何起始状态修饰的规则将不会被匹配。起始状态可以用BEGIN()语句设置。
    本实验中设置了COMMENT和STRING两个独占的起始状态，分别用于注释和字符串的处理。在COMMENT起始状态下，需要匹配的模式有"(*"、"*)"、\n、.和<<EOF>>。匹配到前两个模式时要更改当前注释的嵌套层数，匹配到\n时将curr_lineno加1,匹配到<<EOF>>时返回INITIAL起始状态，匹配到其他字符时不执行任何操作。
三、字符串的处理
    对字符串处理的要求是：
    1、字符串过长，则报错 "String constant too long"。在这个字符串的结束处开始继续分析, 不要为这个字符串生成错误记号之前生成一个string token。
    2、包含了无效字符，则报错"String contains null character"。在这个字符串的结束处开始继续分析, 不要为这个字符串生成错误记号之前生成一个string token。
    3、如果一个字符串包含非转义的换行，则报错 "Unterminated string constant"，并从下一行开始恢复词法分析。这里假设程序员忘记加 close-quote （即右引号）。在生成错误记号前不产生一个 string token。
    4、如果在字符串中遇到了 EOF, 则报错 "EOF in string constant". 不要为这个注释生成 token。
    5、除了"\b"、"\t"、"\r"和"\n"外，遇到"\c"时，转换为"c"再写入字符串。
    与comment类似，对字符串处理需要用到一个STRING起始状态。在INITIAL状态下匹配到"""时进入STRING状态，直到再次遇到"""、非转义换行符或EOF时退出STRING状态。
    本实验中对过长字符串采用这样的处理方式：每次调用string_insert()函数向string_buf中插入字符时，检查string_buf是否已满，若未满则插入，否则插入失败。string_insert()函数调用失败返回后，如果string_too_long标志为0,则将其置为1，并返回错误信息。对于无效字符null采用类似的方式处理，即匹配到null模式时，如果string_error标志为0，则将其置为1，并返回相应错误信息。无论字符串中含有几个null字符，都只产生一条错误信息。
    如果匹配到非转义换行符，将行数加一，退出STRING起始状态并返回错误信息。匹配到EOF时类似处理。
    如果匹配到转义换行符，将行数加一。由于这是一种允许的模式，因此把'\n'写入字符串并继续处理下一行的字符。这个模式被统一在对\\[^btnf]模式的处理中。
    匹配到其他字符时，调用string_insert()函数插入。注意遇到"\c"时，需要根据c的值做特殊处理。
四、备注
    本实现与标准程序的不同之处在于，当字符串中同时出现多类错误时(例如一个过长字符串中含有null)，标准程序只报告一类错误，而本程序会报告所有错误类型。
